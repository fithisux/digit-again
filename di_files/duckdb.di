//===----------------------------------------------------------------------===//////                         DuckDB//// duckdb.h//////===----------------------------------------------------------------------===////// !!!!!!!// WARNING: this file is autogenerated by scripts/generate_c_api.py, manual changes will be overwritten// !!!!!!!//! duplicate of duckdb/main/winapi.hpp//===--------------------------------------------------------------------===//// Enums//===--------------------------------------------------------------------===//// WARNING: the numbers of these enums should not be changed, as changing the numbers breaks ABI compatibility// Always add enums at the END of the enum//! An enum over DuckDB's internal types.alias duckdb_type = enum DUCKDB_TYPE_INVALID = 0,
DUCKDB_TYPE_BOOLEAN = 1,
DUCKDB_TYPE_TINYINT = 2,
DUCKDB_TYPE_SMALLINT = 3,
DUCKDB_TYPE_INTEGER = 4,
DUCKDB_TYPE_BIGINT = 5,
DUCKDB_TYPE_UTINYINT = 6,
DUCKDB_TYPE_USMALLINT = 7,
DUCKDB_TYPE_UINTEGER = 8,
DUCKDB_TYPE_UBIGINT = 9,
DUCKDB_TYPE_FLOAT = 10,
DUCKDB_TYPE_DOUBLE = 11,
DUCKDB_TYPE_TIMESTAMP = 12,
DUCKDB_TYPE_DATE = 13,
DUCKDB_TYPE_TIME = 14,
DUCKDB_TYPE_INTERVAL = 15,
DUCKDB_TYPE_HUGEINT = 16,
DUCKDB_TYPE_UHUGEINT = 32,
DUCKDB_TYPE_VARCHAR = 17,
DUCKDB_TYPE_BLOB = 18,
DUCKDB_TYPE_DECIMAL = 19,
DUCKDB_TYPE_TIMESTAMP_S = 20,
DUCKDB_TYPE_TIMESTAMP_MS = 21,
DUCKDB_TYPE_TIMESTAMP_NS = 22,
DUCKDB_TYPE_ENUM = 23,
DUCKDB_TYPE_LIST = 24,
DUCKDB_TYPE_STRUCT = 25,
DUCKDB_TYPE_MAP = 26,
DUCKDB_TYPE_ARRAY = 33,
DUCKDB_TYPE_UUID = 27,
DUCKDB_TYPE_UNION = 28,
DUCKDB_TYPE_BIT = 29,
DUCKDB_TYPE_TIME_TZ = 30,
DUCKDB_TYPE_TIMESTAMP_TZ = 31,
DUCKDB_TYPE_ANY = 34,
DUCKDB_TYPE_VARINT = 35,
DUCKDB_TYPE_SQLNULL = 36,
DUCKDB_TYPE_STRING_LITERAL = 37,
DUCKDB_TYPE_INTEGER_LITERAL = 38;//! An enum over the returned state of different functions.alias duckdb_state = enum DuckDBSuccess = 0,
DuckDBError = 1;//! An enum over the pending state of a pending query result.alias duckdb_pending_state = enum DUCKDB_PENDING_RESULT_READY = 0,
DUCKDB_PENDING_RESULT_NOT_READY = 1,
DUCKDB_PENDING_ERROR = 2,
DUCKDB_PENDING_NO_TASKS_AVAILABLE = 3;//! An enum over DuckDB's different result types.alias duckdb_result_type = enum DUCKDB_RESULT_TYPE_INVALID = 0,
DUCKDB_RESULT_TYPE_CHANGED_ROWS = 1,
DUCKDB_RESULT_TYPE_NOTHING = 2,
DUCKDB_RESULT_TYPE_QUERY_RESULT = 3;//! An enum over DuckDB's different statement types.alias duckdb_statement_type = enum DUCKDB_STATEMENT_TYPE_INVALID = 0,
DUCKDB_STATEMENT_TYPE_SELECT = 1,
DUCKDB_STATEMENT_TYPE_INSERT = 2,
DUCKDB_STATEMENT_TYPE_UPDATE = 3,
DUCKDB_STATEMENT_TYPE_EXPLAIN = 4,
DUCKDB_STATEMENT_TYPE_DELETE = 5,
DUCKDB_STATEMENT_TYPE_PREPARE = 6,
DUCKDB_STATEMENT_TYPE_CREATE = 7,
DUCKDB_STATEMENT_TYPE_EXECUTE = 8,
DUCKDB_STATEMENT_TYPE_ALTER = 9,
DUCKDB_STATEMENT_TYPE_TRANSACTION = 10,
DUCKDB_STATEMENT_TYPE_COPY = 11,
DUCKDB_STATEMENT_TYPE_ANALYZE = 12,
DUCKDB_STATEMENT_TYPE_VARIABLE_SET = 13,
DUCKDB_STATEMENT_TYPE_CREATE_FUNC = 14,
DUCKDB_STATEMENT_TYPE_DROP = 15,
DUCKDB_STATEMENT_TYPE_EXPORT = 16,
DUCKDB_STATEMENT_TYPE_PRAGMA = 17,
DUCKDB_STATEMENT_TYPE_VACUUM = 18,
DUCKDB_STATEMENT_TYPE_CALL = 19,
DUCKDB_STATEMENT_TYPE_SET = 20,
DUCKDB_STATEMENT_TYPE_LOAD = 21,
DUCKDB_STATEMENT_TYPE_RELATION = 22,
DUCKDB_STATEMENT_TYPE_EXTENSION = 23,
DUCKDB_STATEMENT_TYPE_LOGICAL_PLAN = 24,
DUCKDB_STATEMENT_TYPE_ATTACH = 25,
DUCKDB_STATEMENT_TYPE_DETACH = 26,
DUCKDB_STATEMENT_TYPE_MULTI = 27;//! An enum over DuckDB's different error types.alias duckdb_error_type = enum DUCKDB_ERROR_INVALID = 0,
DUCKDB_ERROR_OUT_OF_RANGE = 1,
DUCKDB_ERROR_CONVERSION = 2,
DUCKDB_ERROR_UNKNOWN_TYPE = 3,
DUCKDB_ERROR_DECIMAL = 4,
DUCKDB_ERROR_MISMATCH_TYPE = 5,
DUCKDB_ERROR_DIVIDE_BY_ZERO = 6,
DUCKDB_ERROR_OBJECT_SIZE = 7,
DUCKDB_ERROR_INVALID_TYPE = 8,
DUCKDB_ERROR_SERIALIZATION = 9,
DUCKDB_ERROR_TRANSACTION = 10,
DUCKDB_ERROR_NOT_IMPLEMENTED = 11,
DUCKDB_ERROR_EXPRESSION = 12,
DUCKDB_ERROR_CATALOG = 13,
DUCKDB_ERROR_PARSER = 14,
DUCKDB_ERROR_PLANNER = 15,
DUCKDB_ERROR_SCHEDULER = 16,
DUCKDB_ERROR_EXECUTOR = 17,
DUCKDB_ERROR_CONSTRAINT = 18,
DUCKDB_ERROR_INDEX = 19,
DUCKDB_ERROR_STAT = 20,
DUCKDB_ERROR_CONNECTION = 21,
DUCKDB_ERROR_SYNTAX = 22,
DUCKDB_ERROR_SETTINGS = 23,
DUCKDB_ERROR_BINDER = 24,
DUCKDB_ERROR_NETWORK = 25,
DUCKDB_ERROR_OPTIMIZER = 26,
DUCKDB_ERROR_NULL_POINTER = 27,
DUCKDB_ERROR_IO = 28,
DUCKDB_ERROR_INTERRUPT = 29,
DUCKDB_ERROR_FATAL = 30,
DUCKDB_ERROR_INTERNAL = 31,
DUCKDB_ERROR_INVALID_INPUT = 32,
DUCKDB_ERROR_OUT_OF_MEMORY = 33,
DUCKDB_ERROR_PERMISSION = 34,
DUCKDB_ERROR_PARAMETER_NOT_RESOLVED = 35,
DUCKDB_ERROR_PARAMETER_NOT_ALLOWED = 36,
DUCKDB_ERROR_DEPENDENCY = 37,
DUCKDB_ERROR_HTTP = 38,
DUCKDB_ERROR_MISSING_EXTENSION = 39,
DUCKDB_ERROR_AUTOLOAD = 40,
DUCKDB_ERROR_SEQUENCE = 41,
DUCKDB_INVALID_CONFIGURATION = 42;//! An enum over DuckDB's different cast modes.alias duckdb_cast_mode = enum DUCKDB_CAST_NORMAL = 0,
DUCKDB_CAST_TRY = 1;//===--------------------------------------------------------------------===//// General type definitions//===--------------------------------------------------------------------===////! DuckDB's index type.alias idx_t = uint64_t;//! Type used for the selection vectoralias sel_t = uint32_t;//! The callback that will be called to destroy data, e.g.,//! bind data (if any), init data (if any), extra data for replacement scans (if any)alias duckdb_delete_callback_t = void; function (void* data);//! Used for threading, contains a task state. Must be destroyed with `duckdb_destroy_task_state`.alias duckdb_task_state = void *;//===--------------------------------------------------------------------===//// Types (no explicit freeing)//===--------------------------------------------------------------------===////! Days are stored as days since 1970-01-01//! Use the duckdb_from_date/duckdb_to_date function to extract individual informationalias duckdb_date = struct int32_t days;alias duckdb_date_struct = struct int32_t year;
int8_t month;
int8_t day;//! Time is stored as microseconds since 00:00:00//! Use the duckdb_from_time/duckdb_to_time function to extract individual informationalias duckdb_time = struct int64_t micros;alias duckdb_time_struct = struct int8_t hour;
int8_t min;
int8_t sec;
int32_t micros;//! TIME_TZ is stored as 40 bits for int64_t micros, and 24 bits for int32_t offsetalias duckdb_time_tz = struct uint64_t bits;alias duckdb_time_tz_struct = struct duckdb_time_struct time;
int32_t offset;//! TIMESTAMP values are stored as microseconds since 1970-01-01.//! Use the duckdb_from_timestamp and duckdb_to_timestamp functions to extract individual information.alias duckdb_timestamp = struct int64_t micros;//! TIMESTAMP_S values are stored as seconds since 1970-01-01.alias duckdb_timestamp_s = struct int64_t seconds;//! TIMESTAMP_MS values are stored as milliseconds since 1970-01-01.alias duckdb_timestamp_ms = struct int64_t millis;//! TIMESTAMP_NS values are stored as nanoseconds since 1970-01-01.alias duckdb_timestamp_ns = struct int64_t nanos;alias duckdb_timestamp_struct = struct duckdb_date_struct date;
duckdb_time_struct time;alias duckdb_interval = struct int32_t months;
int32_t days;
int64_t micros;//! Hugeints are composed of a (lower, upper) component//! The value of the hugeint is upper * 2^64 + lower//! For easy usage, the functions duckdb_hugeint_to_double/duckdb_double_to_hugeint are recommendedalias duckdb_hugeint = struct uint64_t lower;
int64_t upper;alias duckdb_uhugeint = struct uint64_t lower;
uint64_t upper;//! Decimals are composed of a width and a scale, and are stored in a hugeintalias duckdb_decimal = struct uint8_t width;
uint8_t scale;
duckdb_hugeint value;//! A type holding information about the query execution progressalias duckdb_query_progress_type = struct double percentage;
uint64_t rows_processed;
uint64_t total_rows_to_process;//! The internal representation of a VARCHAR (string_t). If the VARCHAR does not//! exceed 12 characters, then we inline it. Otherwise, we inline a prefix for faster//! string comparisons and store a pointer to the remaining characters. This is a non-//! owning structure, i.e., it does not have to be freed.alias varchar_as_pointer = struct uint32_t length;
char[4] prefix;
char* ptr;alias varchar_as_inlined = struct uint32_t length;
char[12] inlined;alias varchar = union varchar_as_pointer pointer;
varchar_as_inlined inlined;alias duckdb_string_t = struct varchar value;//! The internal representation of a list metadata entry contains the list's offset in//! the child vector, and its length. The parent vector holds these metadata entries,//! whereas the child vector holds the dataalias duckdb_list_entry = struct uint64_t offset;
uint64_t length;//! A column consists of a pointer to its internal data. Don't operate on this type directly.//! Instead, use functions such as duckdb_column_data, duckdb_nullmask_data,//! duckdb_column_type, and duckdb_column_name, which take the result and the column index//! as their parametersalias duckdb_column = struct void* deprecated_data;
bool* deprecated_nullmask;
duckdb_type deprecated_type;
char* deprecated_name;
void* internal_data;//! A vector to a specified column in a data chunk. Lives as long as the//! data chunk lives, i.e., must not be destroyed.alias duckdb_vector = struct void* internal_ptr*;//! A selection vector is a possibly duplicative vector of indices, which refer to values in a vector.//! The resulting vector is make up of the values at each index in the selection vector.alias duckdb_selection_vector = struct void* internal_ptr*;//===--------------------------------------------------------------------===//// Types (explicit freeing/destroying)//===--------------------------------------------------------------------===////! Strings are composed of a char pointer and a size. You must free string.data//! with `duckdb_free`.alias duckdb_string = struct char* data;
idx_t size;//! BLOBs are composed of a byte pointer and a size. You must free blob.data//! with `duckdb_free`.alias duckdb_blob = struct void* data;
idx_t size;//! BITs are composed of a byte pointer and a size.//! BIT byte data has 0 to 7 bits of padding.//! The first byte contains the number of padding bits.//! This number of bits of the second byte are set to 1, starting from the MSB.//! You must free `data` with `duckdb_free`.alias duckdb_bit = struct uint8_t* data;
idx_t size;//! VARINTs are composed of a byte pointer, a size, and an is_negative bool.//! The absolute value of the number is stored in `data` in little endian format.//! You must free `data` with `duckdb_free`.alias duckdb_varint = struct uint8_t* data;
idx_t size;
bool is_negative;//! A query result consists of a pointer to its internal data.//! Must be freed with 'duckdb_destroy_result'.alias duckdb_result = struct idx_t deprecated_column_count;
idx_t deprecated_row_count;
idx_t deprecated_rows_changed;
duckdb_column* deprecated_columns;
char* deprecated_error_message;
void* internal_data;//! A database instance cache object. Must be destroyed with `duckdb_destroy_instance_cache`.alias duckdb_instance_cache = struct void* internal_ptr*;//! A database object. Must be closed with `duckdb_close`.alias duckdb_database = struct void* internal_ptr*;//! A connection to a duckdb database. Must be closed with `duckdb_disconnect`.alias duckdb_connection = struct void* internal_ptr*;//! A client context of a duckdb connection. Must be destroyed with `duckdb_destroy_context`.alias duckdb_client_context = struct void* internal_ptr*;//! A prepared statement is a parameterized query that allows you to bind parameters to it.//! Must be destroyed with `duckdb_destroy_prepare`.alias duckdb_prepared_statement = struct void* internal_ptr*;//! Extracted statements. Must be destroyed with `duckdb_destroy_extracted`.alias duckdb_extracted_statements = struct void* internal_ptr*;//! The pending result represents an intermediate structure for a query that is not yet fully executed.//! Must be destroyed with `duckdb_destroy_pending`.alias duckdb_pending_result = struct void* internal_ptr*;//! The appender enables fast data loading into DuckDB.//! Must be destroyed with `duckdb_appender_destroy`.alias duckdb_appender = struct void* internal_ptr*;//! The table description allows querying info about the table.//! Must be destroyed with `duckdb_table_description_destroy`.alias duckdb_table_description = struct void* internal_ptr*;//! Can be used to provide start-up options for the DuckDB instance.//! Must be destroyed with `duckdb_destroy_config`.alias duckdb_config = struct void* internal_ptr*;//! Holds an internal logical type.//! Must be destroyed with `duckdb_destroy_logical_type`.alias duckdb_logical_type = struct void* internal_ptr*;//! Holds extra information used when registering a custom logical type.//! Reserved for future use.alias duckdb_create_type_info = struct void* internal_ptr*;//! Contains a data chunk from a duckdb_result.//! Must be destroyed with `duckdb_destroy_data_chunk`.alias duckdb_data_chunk = struct void* internal_ptr*;//! Holds a DuckDB value, which wraps a type.//! Must be destroyed with `duckdb_destroy_value`.alias duckdb_value = struct void* internal_ptr*;//! Holds a recursive tree that matches the query plan.alias duckdb_profiling_info = struct void* internal_ptr*;//===--------------------------------------------------------------------===//// C API Extension info//===--------------------------------------------------------------------===////! Holds state during the C API extension intialization processalias duckdb_extension_info = struct void* internal_ptr*;//===--------------------------------------------------------------------===//// Function types//===--------------------------------------------------------------------===////! Additional function info.//! When setting this info, it is necessary to pass a destroy-callback function.alias duckdb_function_info = struct void* internal_ptr*;//! The bind info of a function.//! When setting this info, it is necessary to pass a destroy-callback function.alias duckdb_bind_info = struct void* internal_ptr*;//===--------------------------------------------------------------------===//// Scalar function types//===--------------------------------------------------------------------===////! A scalar function. Must be destroyed with `duckdb_destroy_scalar_function`.alias duckdb_scalar_function = struct void* internal_ptr*;//! A scalar function set. Must be destroyed with `duckdb_destroy_scalar_function_set`.alias duckdb_scalar_function_set = struct void* internal_ptr*;//! The bind function of the scalar function.alias duckdb_scalar_function_bind_t = void; function (duckdb_bind_info info);//! The main function of the scalar function.alias duckdb_scalar_function_t = void; function (duckdb_function_info info,duckdb_data_chunk input,duckdb_vector output);//===--------------------------------------------------------------------===//// Aggregate function types//===--------------------------------------------------------------------===////! An aggregate function. Must be destroyed with `duckdb_destroy_aggregate_function`.alias duckdb_aggregate_function = struct void* internal_ptr*;//! A aggregate function set. Must be destroyed with `duckdb_destroy_aggregate_function_set`.alias duckdb_aggregate_function_set = struct void* internal_ptr*;//! Aggregate statealias duckdb_aggregate_state = struct void* internal_ptr*;//! Returns the aggregate state sizealias duckdb_aggregate_state_size = idx_t; function (duckdb_function_info info);//! Initialize the aggregate statealias duckdb_aggregate_init_t = void; function (duckdb_function_info info,duckdb_aggregate_state state);//! Destroy aggregate state (optional)alias duckdb_aggregate_destroy_t = void; function (duckdb_aggregate_state* states,idx_t count);//! Update a set of aggregate states with new valuesalias duckdb_aggregate_update_t = void; function (duckdb_function_info info,duckdb_data_chunk input,duckdb_aggregate_state* states);//! Combine aggregate statesalias duckdb_aggregate_combine_t = void; function (duckdb_function_info info,duckdb_aggregate_state* source,duckdb_aggregate_state* target,idx_t count);//! Finalize aggregate states into a result vectoralias duckdb_aggregate_finalize_t = void; function (duckdb_function_info info,duckdb_aggregate_state* source,duckdb_vector result,idx_t count,idx_t offset);//===--------------------------------------------------------------------===//// Table function types//===--------------------------------------------------------------------===////! A table function. Must be destroyed with `duckdb_destroy_table_function`.alias duckdb_table_function = struct void* internal_ptr*;//! Additional function init info. When setting this info, it is necessary to pass a destroy-callback function.alias duckdb_init_info = struct void* internal_ptr*;//! The bind function of the table function.alias duckdb_table_function_bind_t = void; function (duckdb_bind_info info);//! The (possibly thread-local) init function of the table function.alias duckdb_table_function_init_t = void; function (duckdb_init_info info);//! The main function of the table function.alias duckdb_table_function_t = void; function (duckdb_function_info info,duckdb_data_chunk output);//===--------------------------------------------------------------------===//// Cast types//===--------------------------------------------------------------------===////! A cast function. Must be destroyed with `duckdb_destroy_cast_function`.alias duckdb_cast_function = struct void* internal_ptr*;alias duckdb_cast_function_t = bool; function (duckdb_function_info info,idx_t count,duckdb_vector input,duckdb_vector output);//===--------------------------------------------------------------------===//// Replacement scan types//===--------------------------------------------------------------------===////! Additional replacement scan info. When setting this info, it is necessary to pass a destroy-callback function.alias duckdb_replacement_scan_info = struct void* internal_ptr*;//! A replacement scan function that can be added to a database.alias duckdb_replacement_callback_t = void; function (duckdb_replacement_scan_info info,const char* table_name,void* data);//===--------------------------------------------------------------------===//// Arrow-related types//===--------------------------------------------------------------------===////! Holds an arrow query result. Must be destroyed with `duckdb_destroy_arrow`.alias duckdb_arrow = struct void* internal_ptr*;//! Holds an arrow array stream. Must be destroyed with `duckdb_destroy_arrow_stream`.alias duckdb_arrow_stream = struct void* internal_ptr*;//! Holds an arrow schema. Remember to release the respective ArrowSchema object.alias duckdb_arrow_schema = struct void* internal_ptr*;//! Holds an arrow array. Remember to release the respective ArrowArray object.alias duckdb_arrow_array = struct void* internal_ptr*;//===--------------------------------------------------------------------===//// DuckDB extension access//===--------------------------------------------------------------------===////! Passed to C API extension as parameter to the entrypointalias duckdb_extension_access = struct void function(duckdb_extension_info info,const char* error) set_error;
duckdb_database* function(duckdb_extension_info info) get_database;
const void* function(duckdb_extension_info info,const char* version) get_api;